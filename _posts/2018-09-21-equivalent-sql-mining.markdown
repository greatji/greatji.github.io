---
layout: post
title:  "Equivalent SQL Mining"
date:   2018-09-21 13:20:00 +8000
author: Ji Sun
tags: "database"
categories: blog
---
## Background
Materialized view can improve peformance of batch queries processing significantly, but the first and the most important step of the pipeline is finding common sql subexpressions. We research for several existed tools, including signature-based methods proposed by [Zhou. etc.](http://www.dbis.informatik.hu-berlin.de/fileadmin/lectures/SS2008/Seminar_MatViews/p533-zhou.pdf) and syntax rewriting based method [Cosette](http://cosette.cs.washington.edu/) developed by database group of Washington University. These two methods can not pick equivalent subexpressions in a scalable and efficient way. So we developed a new tool by combining rules and SMT solver for large scale query dataset on ODPS.

## Related Work
### ODPS SQL
This is the SQL module on ODPS whose optimizer is powered by optimizer Calcite. We have accumulated all queries submitted to ODPS service every day, this is the motivation of this project. Playback is a sub-module of ODPS-SQL, which afford methods to extract, transform and parse records in the databases that store daily queries in history, it helps us to focus on sql related research and development.
### Signature-based method
This method tries to denote different operator in query by different signature, each signature contains informations in the query. This method bring less overhead, however, it's hard for this method to recoganize equivalent queries with different join order, select condition and aggregation, and it's also impossible for this method to be extended to solve containment relationship.
### Rule-based deduction method
Cosette is rule-based deduction method, it mainly uses many rules to rewrite the query to another equivalent form. This method is still based on syntax while not semantic, thus, it's hard to handle complicated math expressions. And what's worse, Cosette do not afford easily used API for RelNode in Calcite, and many operators have not been supported yet.
### SMT solver based method
SMT is the problem of determining whether such a formula is satisfiable. Imagine an instance of the boolean satisfiability problem (SAT) in which some of the binary variables are replaced by predicates over a suitable set of non-binary variables. A predicate is basically a binary-valued function of non-binary variables. Example predicates include linear inequalities (e.g.,  { 3x+2y-z >= 4}) or equalities involving uninterpreted terms and function symbols (e.g., {f(f(u,v),v)=f(u,v)} f(f(u,v),v)=f(u,v) where {f} f is some unspecified function of two arguments). In this work, we use z3 from microsoft as the efficient solver tool. There is a method developed by [Qi Zhou](http://gitlab.alibaba-inc.com/zq166665/sql-containments), however, this method has severe performance problems with large queries (either wide or deep).
# Framework
### Program Structure
The new tool adopts 'devide-and-conqure' idea. Equivalence of complicated condition and math expressions is hard to deal with by structure matching, thus we still use microsoft z3 to solve SPJ subexpressions where most condition constrains and math expressions exist. To avoid heavy overhead with large queries, we partition the expression according to Aggregation and TableScan operator horizontally and postpone process the join operators to accalerate join equivalence checking. For TableSink and AdhocSink，only the columns matching matters. For Aggregation, we check the aggregation function and parameter equavalence. And for table scan, we only check the table name. For other unknow or rare operator, we do not check anything but make it transparent to the whole checking process.
![program_structure.png](/figures/sql_equivalence_framework.png) 
### Condition Solver
Within each part of the query, the root is one of the SPJ operators and the leaves are Aggregation or TableScan. We construct one variable for each output column from leaf nodes. By matching Table Columns (TableScan) or using match information passed from below (Aggregation), we can get the first kind of constrains which is correspponding input variables in two expressions to be compared must be the same. To determine if two SPJ subexpressions are equivalent, we need another constrain that is one tuple would be selected or not in both subexpressions, this is the condition constrain. Notice that we also need to check whether the output of each column on the root can be matched. After constructing these constrains, we use z3 to solve a unsatisfiable problem generated from them.
### Online deployment
Thanks to ODPS UDF and UDJ, Our method can be integrated into ODPS SQL seemlessly and easy to use for potential up-coming users. First, we use one UDTF to compile all the queries and extract subexpressions. Second, we compare each pair of subexpressions from different queries and output the equivalent pairs. Unforturnately, we have too much queries to be compared in one bucket which would bring n-square cost complexity. Table names existing in Table Scan, group by keys, attributes existing in where clause and database partition conditions are taken as UDJ Join conditions to reduce number of elements in single bucket. Besides, we found that huge amount of similar queries have much less runtime resource consuming than average which would bring little benefits to share, therefore, we prune these queries to further tailor the buckets.
## Evaluation
### Performance
Because of the limitation of Cosette and signature-based, they are not suitable for our project, In the evaluation, we only show the improvement of method proposed in this work comparing to Qi's method.  
We randomly select 8 compilable DML sql queries and 2 special sql queries to show the scalability of the methods. Notice that No.9 query is very deep with lots of embedded joins and No.10 query is very wide with lots of columns in the aggregation operation. All the following experiments are conducted for self comparing in order to make comparator to walk through the whole queries.  

| time/s |1#|2#|3#|4#|5#|6#|7#|8#|9#|10#|
| -------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- |
| Ji |0.268|1.355|0.712|0.617|0.184|0.348|0.233|0.35|14.146|0.388|
| Qi |0.105|3.952|0.107|0.103|0.141|wrong|wrong|wrong|>1000|>1000|

From table above, Qi's method made 3 misjudgement, and timeout for large queries(either deep or wide).
### Unsupported Cases
In order to improve performence significantly, we ignored some criterion for sql equivalence judgement. However, we do not loss accuracy according to the result calculated from daily queries for the reasons following.
1. ```WHEN...CASE``` is relatively stable for the equavalent queries.
2. ```JOIN``` type is relatively stable for a static join graph.
3. Two intermediate results with different order can be shared, so ```SORT``` is not that important.

|Case|Status|
| -------- | -------- |
|```WHEN...CASE``` clause|Only Type|
|Differences between ```INNER JOIN```, ```LEFT JOIN```, ```RIGHT JOIN``` and ```OUTER JOIN```|Taken As Inner|
|```UNION```|TODO|
|```SORT```|Always True|
|```VALUES```|TODO|

## Appendix
### SQL used in evaluation

| No. | Query |
| -------- | -------- |
|1#| select * from zeus_server_info where ds='20180824' and cabinet_id in (select armory_id from zeus_cabinet_info where ds='20180824' and room_id=201326910); |
|2#|SELECT * FROM (SELECT 0, CAST (COUNT(CASE WHEN biztimelong IS NULL THEN TRUE ELSE NULL END) AS STRING) AS col_0,CAST (COUNT(CASE WHEN sel_selnick IS NULL THEN TRUE ELSE NULL END) AS STRING) AS col_1,CAST (COUNT(1) AS STRING) AS col_2,CAST (COUNT(CASE WHEN righttype IS NULL THEN TRUE ELSE NULL END) AS STRING) AS col_3,CAST (COUNT(CASE WHEN suborderactlpayfee IS NULL THEN TRUE ELSE NULL END) AS STRING) AS col_4,CAST (COUNT(CASE WHEN orderid IS NULL THEN TRUE ELSE NULL END) AS STRING) AS col_5,CAST (COUNT(CASE WHEN tradeendtime IS NULL THEN TRUE ELSE NULL END) AS STRING) AS col_6,CAST (COUNT(CASE WHEN orderpaytime IS NULL THEN TRUE ELSE NULL END) AS STRING) AS col_7,CAST (COUNT(CASE WHEN staterightsale IS NULL THEN TRUE ELSE NULL END) AS STRING) AS col_8,CAST (COUNT(CASE WHEN rightid IS NULL THEN TRUE ELSE NULL END) AS STRING) AS col_9,CAST (COUNT(CASE WHEN byr_usernick IS NULL THEN TRUE ELSE NULL END) AS STRING) AS col_10,CAST (COUNT(CASE WHEN refdstat IS NULL THEN TRUE ELSE NULL END) AS STRING) AS col_11,CAST (COUNT(CASE WHEN rightcostdays IS NULL THEN TRUE ELSE NULL END) AS STRING) AS col_12,CAST (COUNT(CASE WHEN selid IS NULL THEN TRUE ELSE NULL END) AS STRING) AS col_13,CAST (COUNT(CASE WHEN creattime IS NULL THEN TRUE ELSE NULL END) AS STRING) AS col_14,CAST (COUNT(CASE WHEN biztype IS NULL THEN TRUE ELSE NULL END) AS STRING) AS col_15,CAST (COUNT(CASE WHEN refdcashfeefen IS NULL THEN TRUE ELSE NULL END) AS STRING) AS col_16,CAST (COUNT(CASE WHEN questdesc IS NULL THEN TRUE ELSE NULL END) AS STRING) AS col_17,CAST (COUNT(CASE WHEN recvsituval IS NULL THEN TRUE ELSE NULL END) AS STRING) AS col_18,CAST (COUNT(CASE WHEN rptreasn IS NULL THEN TRUE ELSE NULL END) AS STRING) AS col_19,CAST (COUNT(CASE WHEN prodtitle IS NULL THEN TRUE ELSE NULL END) AS STRING) AS col_20,CAST (COUNT(CASE WHEN prodid IS NULL THEN TRUE ELSE NULL END) AS STRING) AS col_21,CAST (COUNT(CASE WHEN byrid IS NULL THEN TRUE ELSE NULL END) AS STRING) AS col_22,CAST (COUNT(CASE WHEN recvsitu IS NULL THEN TRUE ELSE NULL END) AS STRING) AS col_23,CAST (COUNT(CASE WHEN bizendtime IS NULL THEN TRUE ELSE NULL END) AS STRING) AS col_24,CAST (COUNT(CASE WHEN refdfeefen IS NULL THEN TRUE ELSE NULL END) AS STRING) AS col_25 FROM secods.odl_event_crm_rights_end WHERE ds = "201808251730") t;|
|3#|insert overwrite table mdl_tb_activity_false_trade_15min_fdt partition(ds='20180825183000',flag='zhongshu') select t2.order_id,t2.parent_order_id,t2.item_id,t2.category_level1_id,t2.category_leaf_id,t2.gmt_create,t2.gmt_pay,t2.price,t2.buyamount,t2.pay_fee,t2.postfee,t2.discountrate,t2.changepriceratiostr,t2.buyer_id,t2.buyer_nick,t2.seller_id,t2.seller_nick,t2.isblacklistbuyer,t2.sellertype,t2.isb2c,t2.isvirtualproduct,t2.isjhs,t2.iswap,t2.biztype,t2.receivingphone,t2.couponfee from(select seller_id,buyer_id,gmt_member_reg,buyer_cnt1,buyer_cnt2,gmt_pay_hour from mdl_tb_activity_trade_15min_byr_reg_fdt4where ds='20180825183000' and flag_zs=1 and buyer_cnt2>=10 and buyer_cnt2/buyer_cnt1>=0.3 )t1 join ( select*,substr(gmt_pay,1,13)as gmt_pay_hour from mdl_tb_activity_trade_15min_fdt where ds='20180825183000')t2 on(t1.seller_id=t2.seller_id and t1.buyer_id=t2.buyer_id and t1.gmt_pay_hour=t2.gmt_pay_hour);|
|4#|INSERT OVERWRITE table idl_sec_log_dama_http_fht partition (ds='20180825', hh = '08') SELECT request_datetime,host,uri,src_ip,src_port,dst_ip,dst_port,method,referer,user_agent,x_forward_for,cookie,post_data,ret_code,rsp_content_type,rqs_content_type,content_length,jump_location,set_cookie,ttl,token,region,https FROM secods.odl_beaver_log_abtn_http_cloud_split WHERE ds='20180825' and  hh = '08' and split_type='dama_log' and src_ip is not null;|
|5#|select count(*) from alifin_bi.s_49341_hbshouqian_pid_info_tohb1 where dt='20180824';|
|6#|SELECT * from yt_paycenter.t_resource_state where dt = '20180823' and id >= '553459001' and id < '553464001' and resource_type = 'video';|
|7#|SELECT *FROM (SELECT 0, CAST (COUNT(1) AS STRING) AS col_0,CAST (COUNT(1) AS STRING) AS col_1 FROM alisec_app.adl_yt_pwdlogin_trust_coverage_15min_fmt WHERE ds = "201808240000") t;|
|8#|SELECT '支付' AS 业务场景        , T1.USER_ID AS 用户ID        , T1.PROD_ID AS 产品码        , T1.ID AS 单据ID        , T1.OUT_ORDER_NO AS 支付宝交易号        , T1.TRANS_AMOUNT AS pcpay金额        , T2.AMOUNT AS paycore金额        , T1.TRANS_DT AS 业务时间FROM (        SELECT USER_ID                , PROD_ID                , CARD_NO                , ID                , OUT_ORDER_NO                , TRANS_AMOUNT                , TRANS_DT        FROM antods.ods_pcc_payment_order_all_tt_delta_hh        WHERE DT = '20180825'                AND HOUR = '17'                AND TO_CHAR(SUBSTR(TRANS_DT, 1, 19), 'yyyymmddhhmi') >= CONCAT(TO_CHAR(DATEADD(TO_DATE('20180825','yyyymmdd'),-1,'DD'),'yyyymmdd'),'2315')                AND TO_CHAR(SUBSTR(TRANS_DT, 1, 19), 'yyyymmddhhmi') <= CONCAT('20180825', '17', '15')                AND STATUS = 'Y') T1LEFT OUTER JOIN (        SELECT paytool_payment_id                , AMOUNT        FROM antods.ods_pmt_comm_fd_dtl_ob_tt_delta_hh        WHERE DT ='20180825'                AND HOUR = '17'                AND FUND_STATUS = 'S'                AND TRANS_STATUS = 'C'                AND TO_CHAR(SUBSTR(TRANS_DT, 1, 19), 'yyyymmddhhmi') >=CONCAT(TO_CHAR(DATEADD(TO_DATE('20180825','yyyymmdd'),-1,'DD'),'yyyymmdd'),'2315')                AND TO_CHAR(SUBSTR(TRANS_DT, 1, 19), 'yyyymmddhhmi') <= CONCAT('20180825', '17', '15')) T2ON T2.paytool_payment_id = T1.IDWHERE COALESCE(T1.TRANS_AMOUNT, '/') <> COALESCE(T2.AMOUNT, '/');|
|9#|INSERT OVERWRITE TABLE address_match_feature_test PARTITION (ds='20180827')select a.*,if(b.community_tf is not null,b.community_tf,0) as community_tf,if(c.community_sum is not null,c.community_sum,0) as community_sum,    if(group_tf is not null,group_tf,0) as group_tf,if(group_sum is not null,group_sum,0)as group_sum,    if(road_tf is not null,road_tf,0)as road_tf,if(road_sum is not null,road_sum,0)as road_sum,    if(subroad_tf is not null,subroad_tf,0)as subroad_tf,if(subroad_sum is not null,subroad_sum,0)as subroad_sum,    if(roadno_tf is not null,roadno_tf,0)as roadno_tf,if(roadno_sum is not null,roadno_sum,0)as roadno_sum,    if(subroadno_tf is not null,subroadno_tf,0)as subroadno_tf,if(subroadno_sum is not null,subroadno_sum,0)as subroadno_sum,    if(poi_tf is not null,poi_tf,0) as poi_tf,if(poi_sum is not null,poi_sum,0)as poi_sum,    if(subpoi_tf is not null,subpoi_tf,0)as subpoi_tf,if(subpoi_sum is not null,subpoi_sum,0)as subpoi_sum,    if(houseno_tf is not null,houseno_tf,0)as houseno_tf,if(houseno_sum is not null,houseno_sum,0)as houseno_sum,    if(roadnameno_tf is not null,roadnameno_tf,0)as roadnameno_tf,if(roadnameno_sum is not null,roadnameno_sum,0)as roadnameno_sum,    if(roadnamesub_tf is not null,roadnamesub_tf,0)as roadnamesub_tf,if(roadnamesub_sum is not null,roadnamesub_sum,0)as roadnamesub_sum,    if(poisub_tf is not null,poisub_tf,0) as poisub_tf,if(poisub_sum is not null,poisub_sum,0)as poisub_sum,    if(subpoino_tf is not null,subpoino_tf,0)as subpoino_tf,if(subpoino_sum is not null,subpoino_sum,0)as subpoino_sum,    if(poino_tf is not null,poino_tf,0)as poino_tf,if(poino_sum is not null,poino_sum,0)as poino_sum,    if(cellno_tf is not null,cellno_tf,0)as cellno_tf,if(cellno_sum is not null,cellno_sum,0)as cellno_sumfrom     (    select mail_no,    station_id ,    area_id,    community,    group,    road,    subroad,    roadno,    subroadno,    poi,    subpoi,    houseno,    roadnameno,    roadnamesub,    poisub,    subpoino,    poino,    cellno,    label from address_match_test where ds='20180827'    )a left outer join     (        select station_id,area_id,community,count(community) as community_tf from     address_match_sample_pos where ds='20180827'group by     station_id,area_id,community    )bon     a.area_id=b.area_id and a.community=b.communityleft outer join     (        select station_id,community,count(community) as community_sumfrom     address_match_sample_pos where ds='20180827'group by     station_id,community    )con     a.station_id=c.station_id and a.community=c.communityleft outer join     (        select station_id,area_id,group,count(group) as group_tf from     address_match_sample_pos where ds='20180827'group by     station_id,area_id,group    )don     a.area_id=d.area_id and a.group=d.groupleft outer join     (        select station_id,group,count(group) as group_sumfrom     address_match_sample_pos where ds='20180827'group by     station_id,group    )fon     a.station_id=f.station_id and a.group=f.groupleft outer join     (        select station_id,area_id,road,count(road) as road_tf from     address_match_sample_pos where ds='20180827'group by     station_id,area_id,road    )gon     a.area_id=g.area_id and a.road=g.roadleft outer join     (        select station_id,road,count(road) as road_sumfrom     address_match_sample_pos where ds='20180827'group by     station_id,road    )hon     a.station_id=h.station_id and a.road=h.roadleft outer join     (        select station_id,area_id,subroad,count(subroad) as subroad_tf from     address_match_sample_pos where ds='20180827'group by     station_id,area_id,subroad    )ion     a.area_id=i.area_id and a.subroad=i.subroadleft outer join     (        select station_id,subroad,count(subroad) as subroad_sumfrom     address_match_sample_pos where ds='20180827'group by     station_id,subroad    )jon     a.station_id=j.station_id and a.subroad=j.subroadleft outer join     (        select station_id,area_id,roadno,count(roadno) as roadno_tf from     address_match_sample_pos where ds='20180827'group by     station_id,area_id,roadno    )kon     a.area_id=k.area_id and a.roadno=k.roadnoleft outer join     (        select station_id,roadno,count(roadno) as roadno_sumfrom     address_match_sample_pos where ds='20180827'group by     station_id,roadno    )lon     a.station_id=l.station_id and a.roadno=l.roadnoleft outer join     (        select station_id,area_id,subroadno,count(subroadno) as subroadno_tf from     address_match_sample_pos where ds='20180827'group by     station_id,area_id,subroadno    )mon     a.area_id=m.area_id and a.subroadno=m.subroadnoleft outer join     (        select station_id,subroadno,count(subroadno) as subroadno_sumfrom     address_match_sample_pos where ds='20180827'group by     station_id,subroadno    )non     a.station_id=n.station_id and a.subroadno=n.subroadnoleft outer join     (        select station_id,area_id,poi,count(poi) as poi_tf from     address_match_sample_pos where ds='20180827'group by     station_id,area_id,poi    )oon     a.area_id=o.area_id and a.poi=o.poileft outer join     (        select station_id,poi,count(poi) as poi_sumfrom     address_match_sample_pos where ds='20180827'group by     station_id,poi    )pon     a.station_id=p.station_id and a.poi=p.poileft outer join     (        select station_id,area_id,subpoi,count(subpoi) as subpoi_tf from     address_match_sample_pos where ds='20180827'group by     station_id,area_id,subpoi    )qon     a.area_id=q.area_id and a.subpoi=q.subpoileft outer join     (        select station_id,subpoi,count(subpoi) as subpoi_sumfrom     address_match_sample_pos where ds='20180827'group by     station_id,subpoi    )ron     a.station_id=r.station_id and a.subpoi=r.subpoi left outer join     (        select station_id,area_id,houseno,count(houseno) as houseno_tf from     address_match_sample_pos where ds='20180827'group by     station_id,area_id,houseno    )son     a.area_id=s.area_id and a.houseno=s.housenoleft outer join     (        select station_id,houseno,count(houseno) as houseno_sumfrom     address_match_sample_pos where ds='20180827'group by     station_id,houseno    )ton     a.station_id=t.station_id and a.houseno=t.houseno left outer join     (        select station_id,area_id,roadnameno,count(roadnameno) as roadnameno_tf from     address_match_sample_pos where ds='20180827'group by     station_id,area_id,roadnameno    )uon     a.area_id=u.area_id and a.roadnameno=u.roadnamenoleft outer join     (        select station_id,roadnameno,count(roadnameno) as roadnameno_sumfrom     address_match_sample_pos where ds='20180827'group by     station_id,roadnameno    )von     a.station_id=v.station_id and a.roadnameno=v.roadnameno left outer join     (        select station_id,area_id,roadnamesub,count(roadnamesub) as roadnamesub_tf from     address_match_sample_pos where ds='20180827'group by     station_id,area_id,roadnamesub    )won     a.area_id=w.area_id and a.roadnamesub=w.roadnamesubleft outer join     (        s